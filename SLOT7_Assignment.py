# -*- coding: utf-8 -*-
"""Slot7_Assignment

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fH0Wgu-X2WWG_wW29zKl3NSZKaIUdgg8

### **Clusterização de Clientes de Cartão de Crédito**

1. Carregando Bibliotecas
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler, normalize
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA

"""2. Extração e Carregamento do Dataset"""

# Commented out IPython magic to ensure Python compatibility.
# %env KAGGLE_USERNAME=pmbraga12
# %env KAGGLE_KEY=d8bef45982578feea2f68cde81adf4e2

!kaggle datasets download -d arjunbhasin2013/ccdata --unzip -p /content/ccdata
!ls /content/ccdata

DATA_PATH = Path("/content/ccdata")

df = pd.read_csv(DATA_PATH / "CC GENERAL.csv")

#Avaliando carregamento do dataset
df.head()

df.info()
#Colunas com valores nulos: CREDIT_LIMIT e MINIMUM_PAYEMENTS

df.describe()

"""**DICIONÁRIO DATASET:**

LIMPEZA DOS DADOS - Conforme solicitado no exercício
"""

#Identificador de cliente, valores únicos
df = df.drop(axis = 1, columns = 'CUST_ID')

df['MINIMUM_PAYMENTS'].describe()

df['CREDIT_LIMIT'].describe()

df[df['CREDIT_LIMIT'].isnull()]

#Preenchimento dos valores nulos com os valores mínimos
df['MINIMUM_PAYMENTS']= df['MINIMUM_PAYMENTS'].fillna(df['MINIMUM_PAYMENTS'].min())
df['CREDIT_LIMIT']= df['CREDIT_LIMIT'].fillna(df['CREDIT_LIMIT'].min())

df.info() #Valores nulos preenchidos

fig, axes = plt.subplots(3, 3, sharex=True, figsize=(16,8))
sns.boxplot(ax=axes[0, 0], data=df,x=df['BALANCE'])
sns.boxplot(ax=axes[0, 1], data=df,x=df['PURCHASES'])
sns.boxplot(ax=axes[0, 2], data=df,x=df['MINIMUM_PAYMENTS'])
sns.boxplot(ax=axes[1, 0], data=df,x=df['PAYMENTS'])
sns.boxplot(ax=axes[1, 1], data=df,x=df['CREDIT_LIMIT'])
sns.boxplot(ax=axes[1, 2], data=df,x=df['PURCHASES_TRX'])
sns.boxplot(ax=axes[2, 0], data=df,x=df['ONEOFF_PURCHASES'])
sns.boxplot(ax=axes[2, 1], data=df,x=df['CASH_ADVANCE'])
sns.boxplot(ax=axes[2, 2], data=df,x=df['CASH_ADVANCE_TRX'])

#Remoção de outliers com base no solicitado:
df=df[df['BALANCE'] < df['BALANCE'].quantile(0.95)]
df=df[df['PURCHASES'] < df['PURCHASES'].quantile(0.95)]
df=df[df['MINIMUM_PAYMENTS'] < df['MINIMUM_PAYMENTS'].quantile(0.95)]
df=df[df['PAYMENTS'] < df['PAYMENTS'].quantile(0.95)]
df=df[df['CREDIT_LIMIT'] < df['CREDIT_LIMIT'].quantile(0.95)]
df=df[df['PURCHASES_TRX'] < df['PURCHASES_TRX'].quantile(0.95)]
df=df[df['ONEOFF_PURCHASES'] < df['ONEOFF_PURCHASES'].quantile(0.95)]
df=df[df['CASH_ADVANCE'] < df['CASH_ADVANCE'].quantile(0.95)]
df=df[df['CASH_ADVANCE_TRX'] < df['CASH_ADVANCE_TRX'].quantile(0.95)]

#Avaliando a correlação entre as variáveis:

plt.figure(figsize=(12,12))
sns.heatmap(df.corr(), annot=True)
plt.show()

"""K-MEANS"""

scaler = StandardScaler()
df_scaled = scaler.fit_transform(df)

df_scaled.shape
df_scaled

# Select the optimal number of clusters according to "Elbow Method"

scores_1 = []

range_values = range(1, 18)

for i in range_values:
  kmeans = KMeans(n_clusters = i)
  kmeans.fit(df_scaled)
  scores_1.append(kmeans.inertia_) 

plt.plot(scores_1, 'bx-')
plt.title('Deciding the right number of clusters')
plt.xlabel('Clusters')
plt.ylabel('Scores') 
plt.show()

# Apply K-means algorithms
kmeans = KMeans(8)
kmeans.fit(df_scaled)
labels = kmeans.labels_

kmeans.cluster_centers_.shape

cluster_centers = pd.DataFrame(data = kmeans.cluster_centers_, columns = [df.columns])
cluster_centers

# Perform inverse transformation to see the original data
cluster_centers = scaler.inverse_transform(cluster_centers)
cluster_centers = pd.DataFrame(data = cluster_centers, columns = [df.columns])
cluster_centers

# Predict which cluster each customer belong to
y_kmeans = kmeans.fit_predict(df_scaled)
y_kmeans

# Concatenate the clusters labels to original dataframe
df_cluster = pd.concat([df, pd.DataFrame({'CLUSTER':labels})], axis = 1)
df_cluster.head()

# Principal component analysis
pca = PCA(n_components=2)
principal_comp = pca.fit_transform(df_scaled)
principal_comp

# Create a new dataframe with the two components
pca_df = pd.DataFrame(data = principal_comp, columns =['pca1','pca2'])
pca_df.head()

# Concatenate the clusters labels to the dataframe
pca_df = pd.concat([pca_df,pd.DataFrame({'cluster':labels})], axis = 1)
pca_df.head()

plt.figure(figsize=(10,10))
ax = sns.scatterplot(x="pca1", y="pca2", hue = "cluster", data = pca_df, palette =['red','green','blue','pink','yellow','gray','purple', 'black'])
plt.show()