# -*- coding: utf-8 -*-
"""DAY07 - SLOT 6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1D8dPpRQerHN3Bz9Xv6fAosCazepwRFhQ

### **Sistema de Recomendação Razzle Dazzle**

**Bibliotecas**
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

"""**Carregando dados**"""

from google.colab import drive
drive.mount('/content/drive')

df_items = pd.read_csv('drive/MyDrive/Colab Notebooks/SLOT 6 - Finalizados/DNC_order_items_dataset.csv', index_col= 'Unnamed: 0')
df_reviews = pd.read_csv('drive/MyDrive/Colab Notebooks/SLOT 6 - Finalizados/DNC_order_reviews_dataset.csv', index_col= 'Unnamed: 0')
df_orders = pd.read_csv('drive/MyDrive/Colab Notebooks/SLOT 6 - Finalizados/DNC_orders_dataset.csv', index_col= 'Unnamed: 0')
df_products = pd.read_csv('drive/MyDrive/Colab Notebooks/SLOT 6 - Finalizados/DNC_products_dataset.csv', index_col= 'Unnamed: 0')

"""Info"""

df_items.info()

df_reviews.info()

df_orders.info()

df_products.info()

"""Head"""

df_items.head()

df_reviews.head()

df_orders.head()

df_products.head()

df_reviews['review_score'].value_counts()

"""**Dicionário**

**DNC_orders_dataset**

*  order_id – Id do pedido de compra;
*  customer_id – Id do consumidor que realizou a compra;
*  order_status – Status da compra;

**DNC_order_items_dataset**

*  order_id - Id do pedido de compra;
*  order_item_id – Número de produtos em uma mesma compra;
*  product_id – Id do produto;
*  price - preço;

**DNC_products_dataset**
*  product_id – Id do produto;
*  product_category_name – Categoria do produto;
*  product_name_length – Tamanho do nome do produto;
*  product_description_length – comprimento do produto;

**DNC_products_dataset**
*  products_weight_g – peso do produto em g;
*  products_lenght_cm – comprimento do produto em cm;
*  products_height_cm – Altura do produto em cm;
*  product_widht_cm – largura do produto em cm;

**Unindo as Tabelas**
"""

df_0 = df_items.merge(df_reviews, how='outer', on='order_id')
df_1 = df_0.merge(df_orders, how='outer', on='order_id') 
df = df_1.merge(df_products, how='outer', on='product_id')

df.head()

df.isnull().sum()

df.shape

df = df[df['product_id'].notna()]
df = df[df['review_id'].notna()]

#Transformando valores nulos em zero
#Inplace True substituirá para todo DataFrame.

df['product_category_name'].fillna("Sem categoria", inplace = True)
df['product_name_lenght'].fillna(0, inplace = True)
df['product_description_lenght'].fillna(0, inplace = True)
df['product_weight_g'].fillna(0, inplace = True)
df['product_length_cm'].fillna(0, inplace = True)
df['product_height_cm'].fillna(0, inplace = True)
df['product_width_cm'].fillna(0, inplace = True)

df.isnull().sum()

!pip install -U pandas-profiling

from pandas_profiling import ProfileReport
profile = ProfileReport(df)
profile.to_notebook_iframe()

"""### **RECOMENDAÇÕES PARA O CENÁRIO DE COLD START**

1º Produtos que receberam mais de 100 avaliações e possuem maior média de avaliação

2º Produtos que receberam mais de 100 avaliações e possuem o maior score total

3º Produtos com maior número de compras
"""

# Dataframe com produtos com mais de 100 avaliações
df_teste = df[['customer_id','product_id','review_score']] #Organizando DF para utilizar o pacote Surprise
df_teste.head()
new_df = df_teste.groupby('product_id'). filter(lambda x: x['review_score'].count ()>= 100)

"""**Top Produtos com maior média de avaliação**"""

# Criação de um novo DataFrame com classificação média e número de classificações por produto
ratings_df = pd.DataFrame(new_df.groupby('product_id').review_score.mean())

# Adicionando coluna com número de avaliações por produto
ratings_df['review_counts'] = new_df.groupby('product_id').review_score.count()
ratings_df = ratings_df.sort_values('review_score',ascending = False)
ratings_df.head(10)

"""**TOP Produtos Avaliados**"""

ratings_explicit = new_df[new_df['review_score'] != 0] #Coletando reviews diferente de zero devido a desconhecimento se a avaliação foi zero ou nula

ratings_sum = pd.DataFrame(ratings_explicit.groupby(['product_id'])['review_score'].sum())

top10_reviews = ratings_sum.sort_values('review_score', ascending = False).head(10)

#Não é possível afirmar aqui se a soma do review_score são de X quantidades de notas Y
top10_reviews

"""**Top Produtos Encomendados**"""

count = df.groupby(by='product_id', as_index=False) \
  .agg({'order_id': pd.Series.nunique}) \
  .rename(columns={'order_id': 'Order_count'})

buy_count = count.set_index('product_id')
top10_ordered = buy_count.sort_values('Order_count', ascending = False).head(10)
top10_ordered

"""----------------------------------------------

### **Filtragem colaborativa (recomendação item-item)**

Utilizaremos a lógica de que quando pessoas avaliam produtos com notas semelhantes, essas pessoas devem ter gostos semelhantes.
"""

# Importando pacotes
from surprise import KNNWithMeans
from surprise import Dataset
from surprise import accuracy
from surprise import Reader
import os
from surprise.model_selection import train_test_split
from sklearn.decomposition import TruncatedSVD

# Lendo o dataset
reader = Reader(rating_scale=(1, 5)) #score utilizado de 1 a 5
data = Dataset.load_from_df(new_df,reader)

# Split dos dados
trainset, testset = train_test_split(data, test_size=0.3,random_state=10)

# Criação de um modelo baseado em item (user_based true / false para alternar entre filtragem colaborativa baseada em usuário ou baseada em item)
algo = KNNWithMeans(k=5, sim_options={'user_based': False})
algo.fit(trainset)

# Teste do modelo
test_pred = algo.test(testset)

print("Modelo baseado em produto: Test Set")
accuracy.rmse(test_pred, verbose=True)

#get_neighbors(A,B) = Procurar para o item com index A, B itens semelhantes

A = 58  #id do item
B = 10 #k vizinhos mais próximos desejado

input = algo.get_neighbors(A, B)
print ("os index dos produtos recomendados, com base nos outros produtos são:", input)

# Produtos recomendados
out = ratings_df.iloc[input]
out.reset_index(level=0, inplace=True)

out.shape

print("Os produtos recomendados são:")
out

"""-------------------------------------------------------------------------------"""

SIMILARIDADE DE COSSENOS

from sklearn.metrics.pairwise import cosine_similarity
cos_prod = cosine_similarity(ratings_df)
cos_prod

prod_semelhantes = ratings_df.index[3]

print(f'O produto escolhido é: {prod_semelhantes}')

prod_id = ratings_df.index.tolist().index(prod_semelhantes)
print(f'Produto: {prod_semelhantes}, tem índice: {prod_id}')

similares_10 = np.argsort(-cos_prod[prod_id])[1:10]

for i in zip(ratings_df.index[similares_10],cos_prod[prod_id][similares_10]):
  print(f'Produto {i[0]} tem similaridade {i[1]:2f} com produto {prod_semelhantes}')
